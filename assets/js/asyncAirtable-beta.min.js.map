{ "version": 3, "sources": ["webpack://asyncairtable/./node_modules/node-fetch/browser.js", "webpack://asyncairtable/webpack/bootstrap", "webpack://asyncairtable/./src/fetch.ts", "webpack://asyncairtable/./src/arrayFunctions.ts", "webpack://asyncairtable/./src/baseHandlers.ts", "webpack://asyncairtable/./src/logicalFunctions.ts", "webpack://asyncairtable/./src/buildExpression.ts", "webpack://asyncairtable/./src/logicalOperators.ts", "webpack://asyncairtable/./src/textFunctions.ts", "webpack://asyncairtable/./src/typeCheckers.ts", "webpack://asyncairtable/./src/queryBuilder.ts", "webpack://asyncairtable/./src/buildOpts.ts", "webpack://asyncairtable/./src/checkError.ts", "webpack://asyncairtable/./src/checkArg.ts", "webpack://asyncairtable/./src/rateLimitHandler.ts", "webpack://asyncairtable/./src/asyncAirtable.ts"], "names": ["global", "self", "window", "Error", "getGlobal", "module", "exports", "fetch", "default", "bind", "Headers", "Request", "Response", "__webpack_module_cache__", "__webpack_require__", "moduleId", "__webpack_modules__", "arrayFunctions", "$arrayCompact", "fieldName", "$arrayFlatten", "$arrayUnique", "$arrayJoin", "seperator", "baseHandler", "val", "bool", "booleanHandler", "logicalFunctions", "$not", "expression", "queryBuilder", "$and", "args", "$or", "operators", "buildExpression", "obj", "op", "Array", "isArray", "includes", "keys", "Object", "exp", "map", "k", "i", "length", "join", "logicalOperators", "$gt", "$lt", "$gte", "$lte", "$eq", "$neq", "textFunctions", "$textFind", "search", "set", "startIndex", "$textSearch", "isQueryObject", "item", "undefined", "isQueryObjectArray", "arr", "every", "v", "isStringArray", "isStringOrFieldNameObject", "$fieldName", "allIndexesValid", "e", "isBaseField", "arg", "Function", "a", "trim", "vals", "values", "key", "isTextArgs", "valKeys", "subVals", "valKey", "subVal", "opts", "prototype", "hasOwnProperty", "call", "params", "opt", "formatted", "j", "subKey", "encodeURI", "status", "name", "type", "required", "url", "retryTimeout", "maxRetry", "Promise", "resolve", "reject", "retryRateLimit", "setTimeout", "res", "data", "json", "err", "validOptions", "AsyncAirtable", "apiKey", "base", "config", "select", "table", "options", "page", "checkArg", "this", "baseURL", "forEach", "option", "offset", "buildOpts", "headers", "Authorization", "body", "checkError", "JSON", "stringify", "retryOnRateLimit", "rateLimitHandler", "records", "done", "concat", "find", "id", "createRecord", "record", "typecast", "fields", "method", "updateRecord", "destructive", "deleteRecord", "bulkCreate", "bulkUpdate", "bulkDelete", "ids", "query", "upsertRecord", "filterString", "exists", "filterByFormula"], "mappings": "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", "file": "asyncAirtable.min.js", "sourcesContent": ["\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "import * as nodeFetch from 'node-fetch';\nexport default typeof window !== 'undefined'\n  ? window.fetch.bind(window)\n  : ((nodeFetch as unknown) as typeof fetch);\n", "import { ArrayFunctions } from './@types';\n\nexport const arrayFunctions: ArrayFunctions = {\n  $arrayCompact: (fieldName: string): string => {\n    return `ARRAYCOMPACT({${fieldName}})`;\n  },\n  $arrayFlatten: (fieldName: string): string => {\n    return `ARRAYFLATTEN({${fieldName}})`;\n  },\n  $arrayUnique: (fieldName: string): string => {\n    return `ARRAYUNIQUE({${fieldName}})`;\n  },\n  $arrayJoin: (fieldName: string, seperator = ','): string => {\n    return `ARRAYJOIN({${fieldName}}, '${seperator}')`;\n  },\n};\n", "import { BaseFieldType } from './@types';\n\nexport const booleanHandler = (bool: boolean): string => {\n  if (typeof bool !== 'boolean') {\n    throw new Error('Invalid type');\n  }\n  return bool ? 'TRUE()' : 'FALSE()';\n};\n\nexport const baseHandler = (val: BaseFieldType): string => {\n  if (val === null) {\n    return 'BLANK()';\n  }\n  switch (typeof val) {\n    case 'number':\n      return `${val}`;\n    case 'string':\n      return `'${val}'`;\n    case 'boolean':\n      return booleanHandler(val);\n    default:\n      throw new Error('Wrong Type');\n  }\n};\n", "import { LogicalFunctions, QueryObject } from './@types';\nimport { queryBuilder } from './queryBuilder';\n\nexport const logicalFunctions: LogicalFunctions = {\n  $not: (expression: QueryObject) => `NOT(${queryBuilder(expression)})`,\n  $and: (args: QueryObject[]) => `AND(${queryBuilder(args)})`,\n  $or: (args: QueryObject[]) => `OR(${queryBuilder(args)})`,\n};\n", "import { ComparisonObject } from './@types';\nimport { queryBuilder } from './queryBuilder';\n\nconst operators = ['=', '!=', '>', '>=', '<', '<='];\n\nexport const buildExpression = (obj: ComparisonObject, op: string): string => {\n  if (typeof obj !== 'object' || Array.isArray(obj))\n    throw new Error('Missing or Invalid Comparison Object');\n  if (typeof op !== 'string' && !operators.includes(op))\n    throw new Error('Missing or Invalid Comparison Operator');\n  const keys = Object.keys(obj);\n  const expressionMapper = (k: string, i: number) => {\n    const val = queryBuilder(obj[k]);\n    return `{${k}} ${op} ${val}${i < keys.length - 1 ? ', ' : ''}`;\n  };\n\n  const exp = `${keys.map(expressionMapper).join('')}`;\n  return keys.length > 1 ? `AND(${exp})` : exp;\n};\n", "import { LogicalOperators } from './@types';\nimport { buildExpression } from './buildExpression';\n\nexport const logicalOperators: LogicalOperators = {\n  $gt: (val) => {\n    return buildExpression(val, '>');\n  },\n  $lt: (val) => {\n    return buildExpression(val, '<');\n  },\n  $gte: (val) => {\n    return buildExpression(val, '>=');\n  },\n  $lte: (val) => {\n    return buildExpression(val, '<=');\n  },\n  $eq: (val) => {\n    return buildExpression(val, '=');\n  },\n  $neq: (val) => {\n    return buildExpression(val, '!=');\n  },\n};\n", "import { FieldNameObject, QueryObject, TextFunctions } from './@types';\nimport { baseHandler } from './baseHandlers';\nimport { queryBuilder } from './queryBuilder';\n\nexport const textFunctions: TextFunctions = {\n  $textFind: (\n    search: FieldNameObject | string | QueryObject,\n    set: FieldNameObject | string | QueryObject,\n    startIndex = 0,\n  ): string =>\n    `FIND(${\n      typeof search === 'string' ? baseHandler(search) : queryBuilder(search)\n    }, ${\n      typeof set === 'string' ? baseHandler(set) : queryBuilder(set)\n    }, ${startIndex})`,\n  $textSearch: (\n    search: FieldNameObject | string | QueryObject,\n    set: FieldNameObject | string | QueryObject,\n    startIndex = 0,\n  ): string =>\n    `SEARCH(${\n      typeof search === 'string' ? baseHandler(search) : queryBuilder(search)\n    }, ${\n      typeof set === 'string' ? baseHandler(set) : queryBuilder(set)\n    }, ${startIndex})`,\n};\n", "import {\n  QueryObject,\n  QueryField,\n  JoinArgs,\n  TextArgs,\n  FieldNameObject,\n  UncheckedArray,\n  BaseFieldType,\n} from './@types';\n\nexport const isQueryObject = (item: QueryField): item is QueryObject => {\n  if (item === undefined) throw new Error('Missing Query Object');\n  return item !== null && item instanceof Object && !Array.isArray(item);\n};\n\nexport const isQueryObjectArray = (arr: QueryField): arr is QueryObject[] =>\n  arr instanceof Array && arr.every((v: QueryField) => isQueryObject(v));\n\nexport const isStringArray = (arr: QueryField): arr is string[] =>\n  arr instanceof Array && arr.every((v: QueryField) => typeof v === 'string');\n\nexport const isJoinArgs = (arr: string[]): arr is JoinArgs =>\n  isStringArray(arr) && arr.length === 2;\n\nexport const isStringOrFieldNameObject = (\n  val: QueryField,\n): val is string | FieldNameObject =>\n  typeof val === 'string' ||\n  (val instanceof Object &&\n    !Array.isArray(val) &&\n    typeof val?.$fieldName === 'string');\n\nexport const isTextArgs = (arr: QueryField[]): arr is TextArgs =>\n  arr instanceof Array &&\n  ((arr.length === 3 && typeof arr[2] === 'number') ||\n    (arr.length === 2 &&\n      (isStringOrFieldNameObject(arr[0]) || isQueryObject(arr[0])) &&\n      (isStringOrFieldNameObject(arr[1]) || isQueryObject(arr[1]))));\n\nexport const allIndexesValid = (arr: UncheckedArray): arr is QueryField[] =>\n  arr.every((e) => e !== undefined && e !== null);\n\nexport const isBaseField = (item: QueryField): item is BaseFieldType =>\n  typeof item !== 'object' || item === null;\n", "import { QueryField, QueryObject } from './@types';\nimport { arrayFunctions } from './arrayFunctions';\nimport { baseHandler } from './baseHandlers';\nimport { logicalFunctions } from './logicalFunctions';\nimport { logicalOperators } from './logicalOperators';\nimport { textFunctions } from './textFunctions';\nimport {\n  allIndexesValid,\n  isBaseField,\n  isJoinArgs,\n  isQueryObject,\n  isQueryObjectArray,\n  isStringArray,\n  isTextArgs,\n} from './typeCheckers';\n\nexport const queryBuilder = (arg: QueryField): string => {\n  if (arg !== undefined && !(arg instanceof Function)) {\n    if (isBaseField(arg)) {\n      return baseHandler(arg);\n    }\n\n    if (arg instanceof Array) {\n      const str = arg.map((a: QueryField) => queryBuilder(a)).join(', ');\n      return str.trim();\n    }\n\n    const keys = Object.keys(arg);\n    const vals = Object.values(arg);\n\n    if (\n      keys.length > 1 &&\n      allIndexesValid(vals) &&\n      isQueryObjectArray(keys.map((k, i) => ({ [k]: vals[i] })))\n    ) {\n      return logicalFunctions.$and(\n        keys.map((k, i) => ({ [k]: vals[i] })) as QueryObject & QueryObject[],\n      );\n    }\n\n    const key = keys[0];\n\n    if (arg[key] === undefined) {\n      throw new Error('Invalid query');\n    }\n\n    if (key === '$fieldName') {\n      return `{${arg.$fieldName}}`;\n    }\n\n    const val = arg[key] as QueryField;\n    if (val !== undefined) {\n      if (\n        key in logicalFunctions &&\n        (isQueryObject(val) || isQueryObjectArray(val))\n      ) {\n        return logicalFunctions[key](val as QueryObject & QueryObject[]);\n      } else if (key in arrayFunctions) {\n        if (isStringArray(val) && isJoinArgs(val)) {\n          return arrayFunctions[key](...val);\n        } else if (typeof val === 'string') {\n          return arrayFunctions[key](val);\n        }\n      } else if (\n        key in textFunctions &&\n        Array.isArray(val) &&\n        isTextArgs(val)\n      ) {\n        return textFunctions[key](val[0], val[1], val[2] ?? 0);\n      } else if (isQueryObject(val)) {\n        const valKeys = Object.keys(val);\n        const subVals = Object.values(val);\n\n        if (\n          valKeys.length > 1 &&\n          allIndexesValid(subVals) &&\n          isQueryObjectArray(valKeys.map((k, i) => ({ [k]: subVals[i] }))) &&\n          valKeys.every((k) => k in logicalOperators) &&\n          subVals.every((v) => isQueryObject(v) || isBaseField(v))\n        ) {\n          return logicalFunctions.$and(\n            valKeys.map((k, i) => ({\n              [key]: { [k]: subVals[i] },\n            })) as QueryObject & QueryObject[],\n          );\n        }\n\n        const valKey = valKeys[0];\n        const subVal = subVals[0];\n        if (\n          valKey in logicalOperators &&\n          (isQueryObject(subVal) || isBaseField(subVal))\n        ) {\n          return logicalOperators[valKey]({\n            [key]: subVal,\n          });\n        }\n      } else if (isQueryObject(val) || isBaseField(val)) {\n        return logicalOperators.$eq({ [key]: val });\n      }\n    }\n  }\n  throw new Error('Invalid Query Object');\n};\n", "import { SelectOptions } from './@types';\nimport { queryBuilder } from './queryBuilder';\n\nexport default (opts: SelectOptions): string => {\n  if (\n    Object.prototype.hasOwnProperty.call(opts, 'filterByFormula') &&\n    Object.prototype.hasOwnProperty.call(opts, 'where')\n  )\n    throw new Error(\n      'Cannot use both where and filterByFormula as they accomplish the same thing',\n    );\n\n  const params = Object.keys(opts)\n    .map((key: string, i) => {\n      /** @todo Find a better type than any for this */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const opt: any = opts[key as keyof SelectOptions];\n      let formatted;\n      if (Array.isArray(opt)) {\n        formatted = opt\n          .map((item, j) => {\n            switch (typeof item) {\n              case 'object':\n                return Object.keys(item)\n                  .map((subKey) => {\n                    return `${key}[${j}][${subKey}]=${item[subKey]}`;\n                  })\n                  .join('&');\n              case 'string':\n                return `${key}[]=${item}`;\n            }\n          })\n          .join('&');\n      } else {\n        if (key === 'where') {\n          formatted = `filterByFormula=${queryBuilder(opt)}`;\n        } else {\n          formatted = `${key}=${opt}`;\n        }\n      }\n      return i !== 0 ? `&${formatted}` : formatted;\n    })\n    .join('');\n  return encodeURI(params);\n};\n", "export default (status: number): boolean => status >= 300;\n", "import { Arg } from './@types';\n\nexport default (\n  arg: Arg,\n  name: string,\n  type: string,\n  required = true,\n): void => {\n  if (arg === undefined && required)\n    throw new Error(`Argument \"${name}\" is required.`);\n  if (arg === undefined && !required) return;\n  if (typeof arg !== type) {\n    if (type === 'array' && Array.isArray(arg)) return;\n    throw new Error(\n      `Incorrect data type on argument \"${name}\". Received \"${typeof arg}\": expected \"${type}\"`,\n    );\n  }\n};\n", "import fetch from './fetch';\nexport default async (\n  url: string,\n  opts: RequestInit,\n  retryTimeout: number,\n  maxRetry: number,\n  key?: string,\n  /** @todo Find a better type than any for this */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const retryRateLimit = (\n      url: string,\n      opts: RequestInit,\n      retryTimeout: number,\n      maxRetry: number,\n      key?: string,\n    ): void => {\n      if (maxRetry && maxRetry < 1) {\n        reject('Max timeout exceeded');\n      }\n      setTimeout(async () => {\n        try {\n          const res = await fetch(url, opts);\n          const data = await res.json();\n          if (res.status === 429) {\n            return retryRateLimit(\n              url,\n              opts,\n              retryTimeout * 1.5,\n              maxRetry - retryTimeout,\n              key,\n            );\n          }\n          if (key) {\n            resolve(data[key]);\n          } else {\n            resolve(data);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      }, retryTimeout);\n    };\n\n    retryRateLimit(url, opts, retryTimeout, maxRetry, key);\n  });\n};\n", "import fetch from './fetch';\nimport buildOpts from './buildOpts';\nimport checkError from './checkError';\nimport checkArg from './checkArg';\nimport rateLimitHandler from './rateLimitHandler';\nimport {\n  SelectOptions,\n  AirtableDeletedResponse,\n  AirtableRecord,\n  AirtableRecordResponse,\n  AirtableUpdateRecord,\n  DeleteResponse,\n  Fields,\n  Config,\n  queryBody,\n  Typecast,\n  updateOpts,\n  bulkQueryBody,\n} from './@types';\n\n/** @ignore */\ndeclare global {\n  interface Window {\n    AsyncAirtable: typeof AsyncAirtable;\n  }\n}\n\nconst validOptions: string[] = [\n  'fields',\n  'filterByFormula',\n  'maxRecords',\n  'pageSize',\n  'sort',\n  'view',\n  'where',\n];\n\n/**\n * The main AsyncAirtable class.\n */\nexport class AsyncAirtable {\n  /**\n   * @default=true\n   * This decides whether or not the library will\n   * handle retrying a request when rate limited\n   */\n  retryOnRateLimit: boolean;\n  /**\n   * @default=60000\n   * The maxmium amount of time before the\n   * library will stop retrying and timeout when rate limited\n   */\n  maxRetry: number;\n  /**\n   * @default=5000\n   * The starting timeout for the retry. This will get 50%\n   * larger with each try until you hit the maxRetry amount\n   */\n  retryTimeout: number;\n  /** The API Key from AirTable */\n  apiKey: string;\n  /** The base id from AirTable */\n  base: string;\n  /** the base URL to use when making API requests */\n  baseURL: string;\n\n  /**\n   * Creates a new instance of the AsyncAirtable library.\n   * @param apiKey The API Key from AirTable\n   * @param base The base id from AirTable\n   * @param config The config to use for this instance of AsyncAirtable\n   */\n  constructor(apiKey: string, base: string, config?: Config) {\n    if (!apiKey) throw new Error('API Key is required.');\n    if (!base) throw new Error('Base ID is required.');\n    this.apiKey = apiKey;\n    this.base = base;\n    this.retryOnRateLimit = config?.retryOnRateLimit || true;\n    this.retryTimeout = config?.retryTimeout || 5000;\n    this.maxRetry = config?.maxRetry || 60000;\n    this.baseURL = config?.baseURL || 'https://api.airtable.com/v0';\n  }\n\n  /**\n   * Select record(s) from the specified table.\n   * @param table Table name\n   * @param options Options object, used to filter records\n   * @param page Used to get a specific page of records\n   * @returns\n   * @async\n   */\n  select = async (\n    table: string,\n    options?: SelectOptions,\n    page?: number,\n  ): Promise<AirtableRecord[]> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(options, 'options', 'object', false);\n      checkArg(page, 'page', 'number', false);\n      const url = `${this.baseURL}/${this.base}/${table}`;\n      const opts: SelectOptions = options ? { ...options } : {};\n      Object.keys(opts).forEach((option) => {\n        if (!validOptions.includes(option)) {\n          throw new Error(`Invalid option: ${option}`);\n        }\n      });\n      let offset: string | undefined = '';\n      let data: AirtableRecord[] = [];\n      if (page) {\n        for (let i = 0; i < page; i++) {\n          if (offset) {\n            opts.offset = offset;\n          }\n          try {\n            const res: Response = await fetch(`${url}?${buildOpts(opts)}`, {\n              headers: { Authorization: `Bearer ${this.apiKey}` },\n            });\n            const body: AirtableRecordResponse = await res.json();\n            if (checkError(res.status)) {\n              if (res.status !== 429) {\n                throw new Error(JSON.stringify(body));\n              }\n\n              if (this.retryOnRateLimit) {\n                if (i + 1 === page) {\n                  return await rateLimitHandler(\n                    `${url}?${buildOpts(opts)}`,\n                    {\n                      headers: { Authorization: `Bearer ${this.apiKey}` },\n                    },\n                    this.retryTimeout,\n                    this.maxRetry,\n                    'records',\n                  );\n                }\n              }\n            }\n            if (i + 1 === page) {\n              return body.records;\n            }\n            offset = body.offset;\n          } catch (err) {\n            throw new Error(err);\n          }\n        }\n      } else {\n        let done = false;\n        while (!done) {\n          if (offset) {\n            opts.offset = offset;\n          }\n          try {\n            const res: Response = await fetch(`${url}?${buildOpts(opts)}`, {\n              headers: { Authorization: `Bearer ${this.apiKey}` },\n            });\n            const body: AirtableRecordResponse = await res.json();\n            if (checkError(res.status)) {\n              if (res.status !== 429) {\n                throw new Error(JSON.stringify(body));\n              }\n\n              if (this.retryOnRateLimit) {\n                return await rateLimitHandler(\n                  `${url}?${buildOpts(opts)}`,\n                  {\n                    headers: { Authorization: `Bearer ${this.apiKey}` },\n                  },\n                  this.retryTimeout,\n                  this.maxRetry,\n                  'records',\n                );\n              }\n            }\n            data = data.concat(body.records);\n            offset = body.offset;\n            if (!body.offset) {\n              done = true;\n            }\n          } catch (err) {\n            throw new Error(err);\n          }\n        }\n      }\n      return data;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Finds a record on the specified table.\n   * @param table Table name\n   * @param id Airtable record ID\n   * @returns\n   * @async\n   */\n  find = async (table: string, id: string): Promise<AirtableRecord> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(id, 'id', 'string');\n      const url = `${this.baseURL}/${this.base}/${table}/${id}`;\n      const res: Response = await fetch(url, {\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n      });\n      const data: AirtableRecord = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              headers: { Authorization: `Bearer ${this.apiKey}` },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n          );\n        }\n      }\n      return data;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Creates a new record on the specified table.\n   * @param table - Table name\n   * @param record - Record object, used to structure data for insert\n   * @param typecast - Used for allowing the ability to add new selections for Select and Multiselect fields.\n   * @returns\n   * @async\n   */\n  createRecord = async (\n    table: string,\n    record: Fields,\n    typecast?: Typecast,\n  ): Promise<AirtableRecord> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(record, 'record', 'object');\n      checkArg(typecast, 'typecast', 'boolean', false);\n      const url = `${this.baseURL}/${this.base}/${table}`;\n      const body: queryBody = { fields: record };\n      if (typecast !== undefined) {\n        body.typecast = typecast;\n      }\n      const res: Response = await fetch(url, {\n        method: 'post',\n        body: JSON.stringify(body),\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      const data: AirtableRecord = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: 'post',\n              body: JSON.stringify(body),\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n                'Content-Type': 'application/json',\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n          );\n        }\n      }\n      return data;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Updates a record on the specified table.\n   * @param table - Table name\n   * @param record - Record object, used to update data within a specific record\n   * @param opts - An object with options for your update statement\n   * @returns\n   * @async\n   */\n  updateRecord = async (\n    table: string,\n    record: AirtableUpdateRecord,\n    opts?: updateOpts,\n  ): Promise<AirtableRecord> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(record, 'record', 'object');\n      if (opts) {\n        checkArg(opts.destructive, 'opts.desctructive', 'boolean');\n        checkArg(opts.typecast, 'opts.typecast', 'boolean', false);\n      }\n      const url = `${this.baseURL}/${this.base}/${table}/${record.id}`;\n      const body: queryBody = { fields: record.fields };\n      if (opts?.typecast !== undefined) {\n        body.typecast = opts?.typecast;\n      }\n      const res: Response = await fetch(url, {\n        method: opts?.destructive ? 'put' : 'patch',\n        body: JSON.stringify(body),\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      const data: AirtableRecord = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: opts?.destructive ? 'put' : 'patch',\n              body: JSON.stringify(body),\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n                'Content-Type': 'application/json',\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n          );\n        }\n      }\n      return data;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Deletes a record from the specified table.\n   * @param table - Table name\n   * @param id - Airtable record ID\n   * @returns\n   * @async\n   */\n  deleteRecord = async (table: string, id: string): Promise<DeleteResponse> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(id, 'id', 'string');\n      const url = `${this.baseURL}/${this.base}/${table}/${id}`;\n      const res: Response = await fetch(url, {\n        method: 'delete',\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n      });\n      const data: DeleteResponse = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: 'delete',\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n          );\n        }\n      }\n      return data;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Creates multiple new records on the specified table.\n   * @param table - Table name\n   * @param records - An array of Record objects\n   * @param typecast - Used for allowing the ability to add new selections for Select and Multiselect fields.\n   * @returns\n   * @async\n   */\n  bulkCreate = async (\n    table: string,\n    records: Fields[],\n    typecast?: Typecast,\n  ): Promise<AirtableRecord[]> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(records, 'records', 'array');\n      checkArg(typecast, 'typecast', 'boolean', false);\n      const url = `${this.baseURL}/${this.base}/${table}`;\n      const body: bulkQueryBody = {\n        records: records.map((record) => ({\n          fields: record,\n        })),\n      };\n      if (typecast !== undefined) {\n        body.typecast = typecast;\n      }\n      const res: Response = await fetch(url, {\n        method: 'post',\n        body: JSON.stringify(body),\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      const data: AirtableRecordResponse = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: 'post',\n              body: JSON.stringify(body),\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n                'Content-Type': 'application/json',\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n            'records',\n          );\n        }\n      }\n      return data.records;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Updates multiple records on the specified table\n   * @param table - Table name\n   * @param records - An array of Record objects\n   * @param opts - An object with options for your update statement\n   * @returns\n   * @async\n   */\n  bulkUpdate = async (\n    table: string,\n    records: AirtableUpdateRecord[],\n    opts?: updateOpts,\n  ): Promise<AirtableRecord[]> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(records, 'records', 'array');\n      if (opts) {\n        checkArg(opts.destructive, 'opts.desctructive', 'boolean', false);\n        checkArg(opts.typecast, 'opts.typecast', 'boolean', false);\n      }\n      const url = `${this.baseURL}/${this.base}/${table}`;\n      const body: bulkQueryBody = { records };\n      if (opts?.typecast !== undefined) {\n        body.typecast = opts?.typecast;\n      }\n      const res: Response = await fetch(url, {\n        method: opts?.destructive ? 'put' : 'patch',\n        body: JSON.stringify(body),\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      const data: AirtableRecordResponse = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: opts?.destructive ? 'put' : 'patch',\n              body: JSON.stringify(body),\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n                'Content-Type': 'application/json',\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n            'records',\n          );\n        }\n      }\n      return data.records;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Deletes multiple records from the specified table\n   * @param table - Table name\n   * @param ids - Array of Airtable record IDs\n   * @returns\n   * @async\n   */\n  bulkDelete = async (\n    table: string,\n    ids: string[],\n  ): Promise<DeleteResponse[]> => {\n    try {\n      checkArg(table, 'table', 'string');\n      checkArg(ids, 'ids', 'array');\n      let query = '';\n      ids.forEach((id, i) => {\n        if (i !== 0) {\n          query = `${query}&records[]=${id}`;\n        } else {\n          query = `records[]=${id}`;\n        }\n      });\n      const url = `${this.baseURL}/${this.base}/${table}?${encodeURI(query)}`;\n      const res: Response = await fetch(url, {\n        method: 'delete',\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n      });\n      const data: AirtableDeletedResponse = await res.json();\n      if (checkError(res.status)) {\n        if (res.status !== 429) {\n          throw new Error(JSON.stringify(data));\n        }\n\n        if (this.retryOnRateLimit) {\n          return await rateLimitHandler(\n            url,\n            {\n              method: 'delete',\n              headers: {\n                Authorization: `Bearer ${this.apiKey}`,\n              },\n            },\n            this.retryTimeout,\n            this.maxRetry,\n            'records',\n          );\n        }\n      }\n      return data.records;\n    } catch (err) {\n      throw new Error(err);\n    }\n  };\n\n  /**\n   * Checks if a record exists, and if it does updates it, if not creates a new record.\n   * @param table - Table name\n   * @param filterString - The filter formula string used to check for a record\n   * @param record - Record object used to either update or create a record\n   * @param opts - An object with options for your update statement\n   * @returns\n   * @async\n   */\n  upsertRecord = async (\n    table: string,\n    filterString: string,\n    record: Fields,\n    opts?: updateOpts,\n  ): Promise<AirtableRecord> => {\n    checkArg(table, 'table', 'string');\n    checkArg(filterString, 'filterString', 'string');\n    checkArg(record, 'record', 'object');\n    if (opts) {\n      checkArg(opts.destructive, 'opts.desctructive', 'boolean', false);\n      checkArg(opts.typecast, 'opts.typecast', 'boolean', false);\n    }\n    const exists = await this.select(table, { filterByFormula: filterString });\n    if (!exists[0]) {\n      return await this.createRecord(table, record, opts?.typecast);\n    } else {\n      return await this.updateRecord(\n        table,\n        {\n          id: exists[0].id,\n          fields: record,\n        },\n        opts,\n      );\n    }\n  };\n}\n\nif (typeof window !== 'undefined') {\n  window.AsyncAirtable = AsyncAirtable;\n}\n"], "sourceRoot": "" }